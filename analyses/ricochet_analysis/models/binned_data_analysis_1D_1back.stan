/*
* 1D Binned Data - Analyzer
* -----------------------------------------------------
* Author: Joe Johnston <jpj13@mit.edu>
*
* Date: 10 April 2017
*
* Purpose:
*
* Constructs count rate model in Stan for binned 1D data
* Relies on shape files, etc output from
* shape_fake_data_generator.py
* This model assumes there is one signal and one background,
* with all shapes generated by shape_fake_data_generator.py
*
*/


functions{
  // Load libraries
  //    include=ricochet;
}

data{
  // Info about the independent variable:
  //real lb_0;             // x lower bound
  //real<lower=lb_0> ub_0; // x upper bound
  int nBins_0;           // x number of bins

  // Binned signal and background shapes, normalized so 
  // the expected number of counts in bin i is
  // signal_rate*sig_1[i]
  //   + back_rate*back_1[i])
  vector[nBins_0] sig_1;
  vector[nBins_0] back_1;

  // Array with number of data events in each bin
  int fake_data[nBins_0];


  // Bounds on analysis parameters that will be extracted
  real signal_lb;                    // Signal lower bound
  real<lower=signal_lb> signal_ub;   // Signal upper bound
  real background_lb;                      // Background event rate lower bound
  real<lower=background_lb> background_ub; // Background event rate upper bound

  // Info about gaussian fluctuations in data
  real<lower=0.0> cns_gauss_bin_frac; // Fraction the signal can vary in each bin
  real<lower=0.0> cns_gauss_global_frac; // Fraction the overall signal can vary
  //real<lower=0.0> total_bin_variation; // Fraction the total counts is varied in each bin
}

parameters{
  real<lower=signal_lb,upper=signal_ub> signal_rate;   // Signal rate
  real<lower=signal_lb,upper=signal_ub> signal_rate_global_gauss; // Total signal_rate may gaussian flucuate
  vector[nBins_0] log_signal_rate_bins_gauss;          // Signal in each bin, gaussian distributed around signal_rate_global
  //vector[nBins_0] log_n_counts_recon_gauss; // Number of counts in each bin, gaussian distributed
  real<lower=background_lb,upper=background_ub> background_rate;   // Background event rate
}

transformed parameters {
  real signal_rate_global;
  real n_counts_recon[nBins_0];
  //real n_counts_recon_gauss[nBins_0];
  //real n_counts_recon_final[nBins_0];
  vector[nBins_0] signal_rate_bins_gauss;
  vector[nBins_0] signal_rate_bins;

  // Calculate and store signal rate in the first bin for plotting purposes
  real signal_rate_smeared;

  // background_1 and background_2 temporarily saved for plotting purposes
  real background_rate_1;
  real background_rate_2;
  background_rate_1 = background_rate;
  background_rate_2 = 0.0;
  
  if(cns_gauss_global_frac==0.0){
    signal_rate_global = signal_rate;
  }else{
    signal_rate_global = signal_rate_global_gauss;
  }

  for(i in 1:nBins_0){
    signal_rate_bins_gauss[i] = exp(log_signal_rate_bins_gauss[i]);
    if(cns_gauss_bin_frac==0.0){
      signal_rate_bins[i] = signal_rate_global;
    }else{
      signal_rate_bins[i] = signal_rate_bins_gauss[i];
    }
    n_counts_recon[i] = signal_rate_bins[i]*sig_1[i]+
     			     background_rate*back_1[i];
    if (n_counts_recon[i]<0.){
      print(n_counts_recon[i]," Bin ", i);
    }
    //n_counts_recon_gauss[i] = exp(log_n_counts_recon_gauss[i]);
    //if(total_bin_variation!=0.0){
    //  n_counts_recon_final[i] = n_counts_recon_gauss[i];
    //}else{
    //  n_counts_recon_final[i] = n_counts_recon[i];
    //}
  }
  signal_rate_smeared = signal_rate_bins[1]; // Saved for plotting
}

model {

  if(cns_gauss_global_frac!=0.0){
    signal_rate_global_gauss ~ normal(signal_rate,cns_gauss_global_frac*signal_rate);
  }
  if(cns_gauss_bin_frac!=0.0){
    increment_log_prob(sum(log_signal_rate_bins_gauss));  // Jacobian
    signal_rate_bins_gauss ~ normal(signal_rate_global,cns_gauss_bin_frac*signal_rate_global);
  }
  //if(total_bin_variation!=0.0){
  //  increment_log_prob(sum(log_n_counts_recon_gauss));
  //  for(i in 1:nBins_0){
  //    n_counts_recon_gauss[i] ~ normal(n_counts_recon[i],total_bin_variation*n_counts_recon[i]);
  //  }
  //}

  // Fit data to poisson distribution of inputted generated data points
  for(i in 1:nBins_0){
    //target += poisson_lpmf(fake_data[i] | n_counts_recon_final[i]);
    target += poisson_lpmf(fake_data[i] | n_counts_recon[i]);
  }
}
